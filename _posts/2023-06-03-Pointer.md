---
layout: single
title: "C++ 동적할당"
categories:
  - CppStudy
tags:
  - [C++, Pointer, VSCode]
toc: true
toc_sticky: true

Date: 2023-06-03
published: true
---

# new / delete 연산자
## 동적할당
우리가 구글 크롬을 이용해 인터넷 서핑을 한다.

구글 크롬을 실행시킨 순간 크롬이 RAM 에 올라가서 동작하게 된다.

처음 실행되는 순간 컴퓨터는 우리가 10개의 탭을 열지, 20개의 탭을 열지 알지 못한다.

사용자가 최대 20개의 탭을 열 수 있도록 시작부터 20개의 탭이 작동할 RAM 공간을 차지하게 된다면 어떨까?

여러가지 프로그램이 돌아가는 PC 환경 속에서

20개는 커녕 10개의 탭만 사용하더라도 RAM 공간이 낭비되어 굉장히 비효율적이다.

따라서 새로운 탭을 여는 순간 메모리 공간을 더 사용하고, 탭을 닫으면 메모리 공간을 비워주는 동작이 필요하다.

이렇듯 필요한 순간마다 메모리에 할당 및 해제를 하는 행위를 동적할당 이라고 한다.

### new / delete
C++ 언어에서 메모리 할당 및 해제할 때 `new / delete` 연산자를 사용한다.

`new / delete` 는 늘 쌍을 이루어야 한다.

메모리를 할당만 하고 해제하지 않으면 할당된 메모리가 계속 남게 되어 메모리 낭비를 야기한다.

이를 `메모리 누수(memory leak)` 이라고 한다.

```cpp
#include <iostream>
using namespace std;
int main() {
  int* a = new int(5);
  cout << a << ' ' << *a << endl;
  delete a;
}
```
<img width="104" alt="1" src="https://github.com/GonoBae/GonoBae.github.io/assets/87271529/0a940327-898e-4655-95ba-c3bfd5150048">

### delete 후
메모리를 해제하면 그 이후는 어떻게 될까?

메모리를 해제하면 다른 프로그램에서 할당해 사용할 수 있도록 해당 메모리를 운영체제로 반환한다.

그러면 우리가 사용했던 포인터 변수는 삭제되는 걸까?

그렇지 않다.

포인터 변수에는 메모리 주소가 그대로 남아있게 되고 우리가 반환한 주소에도 할당한 값이 남아있다.

위에서 `delete a` 를 하여 해제한 후 `cout` 을 통해 똑같이 출력하게 되면 같은 값을 확인할 수 있다.

운영체제에 반환된 메모리는 다른 프로그램에서 사용될 수 있기에 해제한 메모리를 사용하게 되면 예기치 못한 오류가 발생할 수 있다.

이를 막기 위해 우리는 해제한 메모리 주소를 비워줘야 한다.

그래야 실수로 접근하는 상황을 막을 수 있다.

포인터 변수를 `nullptr` 로 다시 초기화해 주자.

```cpp
  ......
  delete a;
  a = nullptr;
```
