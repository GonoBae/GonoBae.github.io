---
layout: single
title: "SOLID 원칙"
categories:
  - Common
tags:
  - [SOLID]
toc: true
toc_sticky: true

Date: 2022-11-11
published: false
---

# SOLID

## 1. SRP (Single Responsibility Principle) 단일 책임의 원칙

### 이론
**한 클래스는 하나의 책임을 가져야 한다.**

클래스를 변경하는 이유는 단 하나여야 한다.

왜? 유지보수를 효율적으로 하기 위해

### 적용
Player 라는 클래스에 Player의 정보와 Player의 움직임에 대한 기능이 구현되어 있다면

둘 중 어느 하나를 수정하려고 해도 Player 스크립트에서 수정을 해야한다.

스크립트가 길어질수록 유지보수에 비효율적이기 때문에 이를 분리시켜야 한다.

## 2. OCP (Open Close Principle) 개방폐쇄의 원칙

### 이론
**확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다.**

기존 구성요소는 수정이 일어나지 말아야 하며,

기존 구성요소를 쉽게 확장이 가능해야 한다.

기존 구성요소를 수정하게 되면 해당 요소를 이용하는 모듈들을 모두 고쳐야 한다.

매우 비효율적이기 때문에 변경에는 닫혀 있어야 한다.

### 적용
Player 는 Stat 을 가지게 된다.

하지만 Player 뿐만 아니라 Monster 와 같은 객체도 Stat 을 가질 수 있다.

Stat 클래스를 추상화 시킴으로써 Player 와 Monster 가 상속받도록 만들 수 있다.

이를 통해 Stat 을 상속받는 유닛들을 쉽게 만들어 확장이 편리하게 된다.

## 3. LSP (The Liskov Substitution Principle) 리스코브 치환의 원칙

### 이론
**자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다.**

자식클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고

확장만 수행하도록 해야 한다는 원칙이다.

### 적용
게임에서 Monster 라는 베이스 클래스가 있다.

이를 상속받은 Slime, Dragon 등의 서브 클래스가 있다.

공격을 수행할 때
```cs
void SlimeAttack(Slime slime) {
  slime.attack();
}
void DragonAttack(Dragon dragon) {
  dragon.attack();
}
```
다음과 같이 작성하게 되면 확장에 굉장히 불리하다.

이를 대신해서
```cs
void Attack(Monster monster) {
  monster.attack();
}
```
다음과 같이 작성하게 되면 아무리 몬스터의 종류가 증가해도

작동에 전혀 문제가 없다.

## 4. ISP (Interface Segregation Principle) 인터페이스 분리의 원칙

### 이론
클라이언트는 자신이 사용하는 메소드에만 의존해야 한다는 원칙

각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써,

클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록

만들어야 하는 것이 핵심!!!

### 적용
Unity 에는 여러가지 인터페이스가 존재한다.

## 5. DIP (Dependency Inversion Principle) 의존성 역전의 원칙

### 이론

### 적용
