---
layout: single
title: "실용주의 프로그래머 Day 8"
categories:
  - Book
tags:
  - [Book, 노마드코더, 북클럽, 노개북, 실용주의 프로그래머]

date: 2022-05-23
published: true
---

# 연습문제 풀어보기!

## 문제17
일부 C 나 C++ 개발자들은 어떤 포인터가 가리키는 메모리를 해제한 다음에는

반드시 그 포인터 값을 NULL로 설정한다. 왜 이것이 좋은 생각일까?

## 나의 풀이
C++ 에서는 `new` 를 통해 동적할당을 하고 `delete` 을 통해 해제한다.

C++ 에서는 `delete` 를 통해 메모리를 운영체제에 반환하면

`0x8123` 이라는 공통된 주소값을 가리키게 된다.

![1](https://user-images.githubusercontent.com/87271529/169710504-1ed48fc4-517e-4811-a454-59fef42a5bbb.png)

해제하면 nullptr (0) 이 되는게 아니구나 라는 것을 깨닫고 왜 그럴까? 고민을 했다.

우선 내가 생각한 이유는 이렇다.

delete 연산자는 포인터가 nullptr 이면 연산을 하지 않는다. 즉 무시한다.

만약 내가 이미 delete 해준 변수가 있는데 실수로 또 delete 를 해도 오류가 나지 않는다.

> 비교샷

![2](https://user-images.githubusercontent.com/87271529/169710526-fe491cb3-1302-456d-bda9-8152bc703338.png)

**nullptr 하기 전**

![3](https://user-images.githubusercontent.com/87271529/169710541-51ed2812-d5fe-47e7-b373-0ebc2300a42c.png)

**nullptr 한 후**

C++ 에서 delete 후 굳이 nullptr 이라고 선언할 필요는 없을 듯 하다.

그냥 굳이...? 라는 생각이 든다.

무조건 해야하는 이유가 있다면 누가 좀 알려줬으면 좋겠다ㅋㅋ

## 해설
대부분의 C 나 C++ 구현에서는 어떤 포인터가 정말로 유효한 메모리를 가리키는지 확인할 방법이 없다.

어떤 메모리 영역의 할당을 해제한 후 나중에 프로그램에서 그 메모리를 참조하는 실수가 자주 일어난다.

그때쯤이면 포인터가 가리키는 메모리는 다른 용도로 다시 할당되었을 수도 있다.

포인터에 NULL 을 지정하여 이런 잘못된 참조를 막으려는 것이다.

대부분의 구현에서 NULL 포인터를 참조하면 런타임 오류가 발생한다.
